////Дан набор из 10 целых чисел. Создать вектор. Переопределить вектор так, чтобы сначала были все элементы, 
////меньшие 5-го элемента, потом большие. (Например, вектор - 2 7 5 8 3  и опорный элемент - второй, 
////даст ответ 2 3 5 7 8)
// 
////Дан набор из 10 целых чисел.Создать список.Выполнить циклический сдвиг списка так,
////чтобы на первом месте стоял первый максимальный элемент. (Например, список - 2 7 5 8 3  даст ответ  8 3 2 7 5).
// 
////Дан набор из 10 целых чисел.Создать вектор.Переопределить вектор так, чтобы он представлял из себя кучу
////(почти полное бинарное дерево, у которого родитель больше своих детей). 
////(Например, вектор - 2 7 5 8 3 даст ответ - 8 7 5 2 3).
//
////Даны два набора из 10 целых чисел.Создать из них списки.Найти скалярное произведение данных списков.
//
////Дана строка.Используя множество, найти количество различных букв в строке.
//#include<iostream>
//#include<vector>
//#include<list>
//#include <set>
//#include <string>
//#include<algorithm>
//#include <numeric>
//using namespace std;
//void print_v(vector<int> a) {
//	for (vector<int>::iterator iter = a.begin(); iter != a.end(); iter++)// вывожу  вектор
//		cout << *iter << ' ';
//	cout << endl;
//}
//
//void print_l(list<int> a) {
//	for (list<int>::iterator iter = a.begin(); iter != a.end(); iter++)// вывожу  список
//		cout << *iter << ' ';
//	cout << endl;
//}
//
//void one (vector<int> a) {
//	cout << "№1 : " << endl;
//	print_v(a);
//	nth_element(a.begin(), a.begin() + 5, a.end());//Разделяет диапазон элементов, правильно находя n-й элемент последовательности в диапазоне, чтобы все элементы перед ними были меньше или равны ему, а все элементы, которые следуют за ним в последовательности, больше или равны ему.
//	print_v(a);
//}
//
//void two(list<int> a) {
//	cout << "№2 : " << endl;
//	print_l(a);
//	list<int>::iterator maxx = max_element(a.begin(), a.end());//ищем максималный элемент
//	rotate(a.begin(), maxx, a.end());//Меняет местами элементы в двух соседних диапазонах.
//	print_l(a);
//}
//
//void tree(vector<int> a) {
//	cout << "№3 : " << endl;
//	print_v(a);
//	make_heap(a.begin(), a.end());//Преобразует элементы из указанного диапазона в кучу, в которой первый элемент является наибольшим и для которой критерий сортировки может быть определен бинарным предикатом.
//	print_v(a);
//}
//
//void four(list<int> a, list<int> b) {
//	cout << "№4 : " << endl;
//	print_l(a);
//	print_l(b);
//	cout << inner_product(a.begin(), a.end(), b.begin(), 0) << endl;// Вычисляет сумму поэлементного умножения двух диапазонов и добавляет ее к указанному начальному значению либо вычисляет результат обобщенной процедуры, где бинарные операции суммы и умножения заменены на другие указанные бинарные операции
//}
//
//void five(set<char> a, string str) {
//	cout << "№5 : " << endl;
//	for (int i = 0; i < str.length(); i++)// не знаю как через стандартную ф-ию преобразовать из строчки в сет
//		a.insert(str[i]);
//	cout << a.size() << endl;
//}
//
//int main() {
//	vector<int> a = { 1, 2, 33, 41 , 55, 6, 77, 8, 9, 10 };
//	one(a);
//	list<int> b = { 11, 2, 33, 4 , 5, 6, 77, 8, 9, 10 };
//	two(b);
//	vector<int> c = { 1, 22, 3, 41 , 55, 63, 77, 81, 9, 10 };
//	tree(c);
//	list<int> d1 = { 11, 2, 33, 4 , 52, 6, 71, 8, 9, 10 };
//	list<int> d2 = { 11, 22, 3, 4 , 5, 6, 77, 8, 9, 110 };
//	four(d1,d2);
//	set<char> e;
//	string str = "sfdesed334g45ggggggggggggggg";
//	five(e,str);
//	return 0;
//}